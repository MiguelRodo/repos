[
  {
    "objectID": "AGENTS.html",
    "href": "AGENTS.html",
    "title": "AGENTS.md",
    "section": "",
    "text": "Configuration for AI coding agents (e.g., Google Jules, GitHub Copilot) working in this repository.\n\n\n\nrepos is a command-line tool for managing multiple related Git repositories as a unified workspace. The primary workflow is:\n\nA user creates a repos.list file listing repositories (and optionally branches) they want cloned.\nRunning repos setup clones them all into the parent directory of the current location, creating the remote repositories on GitHub (via the API) if they do not already exist.\nRunning repos run executes a script inside each cloned repository.\n\nThe codebase is built around Bash scripts as the core engine. Language wrappers (R and Python) exist to expose the same functionality from those runtimes by bundling and invoking the Bash scripts via system2() / subprocess.run().\nKey architectural patterns: - All real logic lives in scripts/ (and scripts/helper/); the top-level bin/repos dispatcher delegates to them. - Repositories are always cloned to the parent directory of the working directory — never inside it. - Branch-only clones use Git worktrees, not fresh clones. - Fallback repository logic: a bare @&lt;branch&gt; line reuses the most recently seen repo (or the current repo’s remote if none has been seen yet).\n\n\n\n\n\n\n\n\n\nLayer\nTechnology\n\n\n\n\nShell\nBash (POSIX-compatible where possible)\n\n\nVCS\nGit (including git worktree)\n\n\nHTTP / GitHub API\ncurl + jq\n\n\nGitHub auth\nGH_TOKEN env var or gh CLI\n\n\n\n\n\n\n\n\n\nLanguage\nEntry point\n\n\n\n\nR\nR/ package; functions in R/repos.R\n\n\nPython\nsrc/repos/ package; entry point src/repos/__init__.py\n\n\n\n\n\n\n\n\n\nPlatform\nFormat\n\n\n\n\nUbuntu / Debian\n.deb (built with dpkg-buildpackage)\n\n\nmacOS\nHomebrew formula (homebrew/)\n\n\nWindows\nScoop manifest (scoop/)\n\n\nLanguage\npip (pyproject.toml), devtools/GitHub (DESCRIPTION)\n\n\n\n\n\n\n\nAny shell other than Bash for new scripts (avoid zsh-only or fish syntax).\nPython or R for core logic — keep the Bash scripts as the single source of truth.\nExternal tools beyond bash, git, curl, and jq as hard runtime dependencies.\n\n\n\n\n\n\n# Clone the repository\ngit clone https://github.com/MiguelRodo/repos.git\ncd repos\n\n# Install to ~/.local/bin (no sudo required)\nbash install-local.sh\n\n# Verify installation\nrepos --help\nIf ~/.local/bin is not on your PATH:\nexport PATH=\"$HOME/.local/bin:$PATH\"\n# Persist by adding the line above to ~/.bashrc or ~/.profile\n\n\n# Ubuntu / Debian\nsudo apt-get install bash git curl jq\n\n# macOS (Homebrew)\nbrew install git curl jq\n\n\n\n\n\n\n\nTests are plain Bash scripts located in tests/. Run them individually or all at once:\n# Run a specific test\nbash tests/test-setup-repos-local.sh\n\n# Run all tests (from the repo root)\nfor t in tests/test-*.sh; do\n  echo \"==&gt; $t\"\n  bash \"$t\"\ndone\nNotable test files: | File | What it covers | |—|—| | tests/test-setup-repos-local.sh | Full integration test using local bare git remotes (no network required) | | tests/test-repos-list-flags.sh | Parsing of global and per-line flags in repos.list | | tests/test-auth-check.sh | GitHub token validation logic | | tests/test-clone-repos-flags.sh | Flag handling in clone-repos.sh | | tests/test-worktree-tracking.sh | Worktree creation and tracking |\n\n\n\nNo automated linter is currently configured in CI/CD. When editing Bash scripts, follow shellcheck best practices:\n# Install shellcheck\nsudo apt-get install shellcheck   # Ubuntu/Debian\nbrew install shellcheck           # macOS\n\n# Lint a script\nshellcheck scripts/setup-repos.sh\nshellcheck scripts/helper/clone-repos.sh\n\n\n\npip install -e .          # Install in editable mode\npython -c \"from repos import setup; print('ok')\"\n\n\n\ndevtools::load_all()      # Load package for development\ndevtools::test()          # Run R tests (if any)\n\n\n\n\n\n\n\n\nUse set -e at the top of every script to fail fast on errors.\nUse mktemp (never predictable /tmp/$name_$$) for temporary files.\nQuote all variable expansions: \"$var\", \"${arr[@]}\".\nUse local for variables inside functions.\nSanitize filesystem names derived from branch names by replacing / with - (e.g., feature/x → feature-x for directory names, while the actual git branch name is preserved).\nAdd a brief comment header at the top of each script describing its purpose.\n\n\n\n\n\nUse the imperative mood in the subject line: “Add flag for –public”, not “Added …”.\nKeep the subject line under 72 characters.\nReference the relevant issue or PR where applicable.\n\n\n\n\n\nOne logical change per PR.\nAll existing tests must pass before merging.\nAdd or update tests in tests/ when changing script behaviour.\nDo not introduce new runtime dependencies without updating the Dependencies section in README.md."
  },
  {
    "objectID": "AGENTS.html#core-philosophy-project-context",
    "href": "AGENTS.html#core-philosophy-project-context",
    "title": "AGENTS.md",
    "section": "",
    "text": "repos is a command-line tool for managing multiple related Git repositories as a unified workspace. The primary workflow is:\n\nA user creates a repos.list file listing repositories (and optionally branches) they want cloned.\nRunning repos setup clones them all into the parent directory of the current location, creating the remote repositories on GitHub (via the API) if they do not already exist.\nRunning repos run executes a script inside each cloned repository.\n\nThe codebase is built around Bash scripts as the core engine. Language wrappers (R and Python) exist to expose the same functionality from those runtimes by bundling and invoking the Bash scripts via system2() / subprocess.run().\nKey architectural patterns: - All real logic lives in scripts/ (and scripts/helper/); the top-level bin/repos dispatcher delegates to them. - Repositories are always cloned to the parent directory of the working directory — never inside it. - Branch-only clones use Git worktrees, not fresh clones. - Fallback repository logic: a bare @&lt;branch&gt; line reuses the most recently seen repo (or the current repo’s remote if none has been seen yet)."
  },
  {
    "objectID": "AGENTS.html#tech-stack-tooling",
    "href": "AGENTS.html#tech-stack-tooling",
    "title": "AGENTS.md",
    "section": "",
    "text": "Layer\nTechnology\n\n\n\n\nShell\nBash (POSIX-compatible where possible)\n\n\nVCS\nGit (including git worktree)\n\n\nHTTP / GitHub API\ncurl + jq\n\n\nGitHub auth\nGH_TOKEN env var or gh CLI\n\n\n\n\n\n\n\n\n\nLanguage\nEntry point\n\n\n\n\nR\nR/ package; functions in R/repos.R\n\n\nPython\nsrc/repos/ package; entry point src/repos/__init__.py\n\n\n\n\n\n\n\n\n\nPlatform\nFormat\n\n\n\n\nUbuntu / Debian\n.deb (built with dpkg-buildpackage)\n\n\nmacOS\nHomebrew formula (homebrew/)\n\n\nWindows\nScoop manifest (scoop/)\n\n\nLanguage\npip (pyproject.toml), devtools/GitHub (DESCRIPTION)\n\n\n\n\n\n\n\nAny shell other than Bash for new scripts (avoid zsh-only or fish syntax).\nPython or R for core logic — keep the Bash scripts as the single source of truth.\nExternal tools beyond bash, git, curl, and jq as hard runtime dependencies."
  },
  {
    "objectID": "AGENTS.html#setup-commands",
    "href": "AGENTS.html#setup-commands",
    "title": "AGENTS.md",
    "section": "",
    "text": "# Clone the repository\ngit clone https://github.com/MiguelRodo/repos.git\ncd repos\n\n# Install to ~/.local/bin (no sudo required)\nbash install-local.sh\n\n# Verify installation\nrepos --help\nIf ~/.local/bin is not on your PATH:\nexport PATH=\"$HOME/.local/bin:$PATH\"\n# Persist by adding the line above to ~/.bashrc or ~/.profile\n\n\n# Ubuntu / Debian\nsudo apt-get install bash git curl jq\n\n# macOS (Homebrew)\nbrew install git curl jq"
  },
  {
    "objectID": "AGENTS.html#build-test-instructions",
    "href": "AGENTS.html#build-test-instructions",
    "title": "AGENTS.md",
    "section": "",
    "text": "Tests are plain Bash scripts located in tests/. Run them individually or all at once:\n# Run a specific test\nbash tests/test-setup-repos-local.sh\n\n# Run all tests (from the repo root)\nfor t in tests/test-*.sh; do\n  echo \"==&gt; $t\"\n  bash \"$t\"\ndone\nNotable test files: | File | What it covers | |—|—| | tests/test-setup-repos-local.sh | Full integration test using local bare git remotes (no network required) | | tests/test-repos-list-flags.sh | Parsing of global and per-line flags in repos.list | | tests/test-auth-check.sh | GitHub token validation logic | | tests/test-clone-repos-flags.sh | Flag handling in clone-repos.sh | | tests/test-worktree-tracking.sh | Worktree creation and tracking |\n\n\n\nNo automated linter is currently configured in CI/CD. When editing Bash scripts, follow shellcheck best practices:\n# Install shellcheck\nsudo apt-get install shellcheck   # Ubuntu/Debian\nbrew install shellcheck           # macOS\n\n# Lint a script\nshellcheck scripts/setup-repos.sh\nshellcheck scripts/helper/clone-repos.sh\n\n\n\npip install -e .          # Install in editable mode\npython -c \"from repos import setup; print('ok')\"\n\n\n\ndevtools::load_all()      # Load package for development\ndevtools::test()          # Run R tests (if any)"
  },
  {
    "objectID": "AGENTS.html#coding-style-conventions",
    "href": "AGENTS.html#coding-style-conventions",
    "title": "AGENTS.md",
    "section": "",
    "text": "Use set -e at the top of every script to fail fast on errors.\nUse mktemp (never predictable /tmp/$name_$$) for temporary files.\nQuote all variable expansions: \"$var\", \"${arr[@]}\".\nUse local for variables inside functions.\nSanitize filesystem names derived from branch names by replacing / with - (e.g., feature/x → feature-x for directory names, while the actual git branch name is preserved).\nAdd a brief comment header at the top of each script describing its purpose.\n\n\n\n\n\nUse the imperative mood in the subject line: “Add flag for –public”, not “Added …”.\nKeep the subject line under 72 characters.\nReference the relevant issue or PR where applicable.\n\n\n\n\n\nOne logical change per PR.\nAll existing tests must pass before merging.\nAdd or update tests in tests/ when changing script behaviour.\nDo not introduce new runtime dependencies without updating the Dependencies section in README.md."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "repos - Multi-Repository Management Tool",
    "section": "",
    "text": "A command-line tool for managing multiple related Git repositories as a unified workspace."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Overview",
    "text": "Overview\nMany projects consist of multiple repositories. For instance, an analysis project might have one repository for data curation and another for analysis. To facilitate this workflow, you can create a repos.list file that specifies the repositories and their branches, and then run repos to clone them (creating repositories and branches as needed).\nHere’s an example repos.list file:\nmyorg/data-curation\nmyorg/analysis\nmyorg/documentation\nRun repos to clone them, and create them if they do not exist:\nrepos\nThis creates the following directory structure:\nworkspace/\n├── my-project/          # Your main project (contains repos.list)\n├── data-curation/       # Cloned from myorg/data-curation\n├── analysis/            # Cloned from myorg/analysis\n└── documentation/       # Cloned from myorg/documentation\n\nCustomizations\n\nrepos.list\n\nClone to a specific path, e.g. myorg/data-curation data\nClone specific branches, e.g. owner/repo@branch\nCreate worktrees from the current repository using --worktree, e.g. owner/repo@branch --worktree\nSkip specifying repository in repos.list, as previous repo listed or current repo used as default.\n\nFor example, specifying @data-curation in the first line would use the current repository as its repository\nAlternately, specifying @dev in the line after myorg/analysis would clone the dev branch from myorg/analysis\n\nCreate repositories as public using the --public flag, e.g. owner/repo --public\n\n\nGlobal Flags in repos.list\nYou can specify global flags at the start of any line in repos.list (with only blank space or comments after the flag):\n\n--codespaces - Enable Codespaces authentication for all repositories\n--public - Create all repositories as public by default\n--private - Create all repositories as private by default\n--worktree - Create all branch clones as worktrees instead of separate clones\n\nExample:\n--public\n--codespaces\nmyorg/repo1\nmyorg/repo2\n\n\nPer-Line Flags\nYou can also specify --public or --private on individual repository lines to override the global setting:\nExample:\n--private             # Default to private\nmyorg/public-repo --public   # Override: create as public\nmyorg/private-repo    # Use default: private\n\n\n\nrepos\n\nEnable Codespaces authentication with --codespaces, e.g. repos --codespaces\nSpecify custom devcontainer.json paths with -d, e.g. repos -d .devcontainer/prebuild/devcontainer.json\n\nUse multiple -d flags to specify multiple devcontainer.json files"
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Installation",
    "text": "Installation\nYou can install repos as a system package (Ubuntu/Debian, macOS, Windows), from source, or as a language-specific wrapper (R or Python).\n\nUbuntu/Debian\nInstall the .deb package to use the repos command system-wide.\nDownload and install the latest .deb package from the Releases page:\n# Download the latest release (replace VERSION_REPOS with desired version; we try to ensure this is the latest one)\nVERSION_REPOS=1.0.9\nwget https://github.com/MiguelRodo/repos/releases/download/v${VERSION_REPOS}/repos_${VERSION_REPOS}_all.deb\n\n# Install the package\nsudo dpkg -i repos_${VERSION_REPOS}_all.deb\n\n# Remove installation file\nrm repos_${VERSION_REPOS}_all.deb\n\n# If there are dependency issues, run:\nsudo apt-get install -f\nRun the repos command:\nrepos\n\nDependencies\nThe package automatically handles dependencies, but requires: - bash - Shell interpreter - git - Version control - curl - HTTP client - jq - JSON processor\nThese are typically pre-installed on Ubuntu/Debian systems. If not:\nsudo apt-get install bash git curl jq\n\n\n\nWindows (Scoop)\nInstall using Scoop to use the repos command in your shell.\nInstall using Scoop:\n# Add the repos bucket (replace &lt;username&gt; with the bucket owner)\nscoop bucket add repos https://github.com/&lt;username&gt;/scoop-bucket\n\n# Install repos\nscoop install repos\nRun the repos command:\nrepos\nDependencies (git and jq) are automatically installed by Scoop. You’ll also need Git for Windows for bash support.\n\n\nWindows (Manual)\nInstall manually to use the repos command in PowerShell or Git Bash.\n\nClone the repository:\ngit clone https://github.com/MiguelRodo/repos.git\ncd repos\nRun the installer:\n.\\install.ps1\nRestart your PowerShell session for the PATH changes to take effect.\nVerify installation:\nrepos --help\n\nRun the repos command:\nrepos\n\nWindows Dependencies\n\nGit for Windows (required for bash, git, and curl): Download here\njq (required for JSON processing): Download here\n\n\n\n\nmacOS (Homebrew)\nInstall using Homebrew to use the repos command system-wide.\nInstall using Homebrew:\n# Add the repos tap (replace &lt;username&gt; with the tap owner)\nbrew tap &lt;username&gt;/repos\n\n# Install repos\nbrew install repos\nRun the repos command:\nrepos\nThe formula automatically handles the jq dependency. Git is typically pre-installed on macOS.\n\n\nFrom Source\nInstall from source to use the repos command or run scripts directly.\ngit clone https://github.com/MiguelRodo/repos.git\ncd repos\n\n# For Ubuntu/Debian\nsudo dpkg-buildpackage -us -uc -b\nsudo dpkg -i ../repos_*.deb\n\n# For other systems, use the scripts directly\n./scripts/setup-repos.sh\nRun the repos command:\nrepos\n\n\nLanguage Wrappers\nThe repository also provides native R and Python packages that wrap the underlying Bash scripts, making it easy to use repos from your preferred language environment.\n\nR Package\nInstall the R package to use repos from within R.\nInstall directly from GitHub using devtools:\n# Install devtools if you haven't already\ninstall.packages(\"devtools\")\n\n# Install repos package\ndevtools::install_github(\"MiguelRodo/repos\")\n\n# Use the repos function\nlibrary(repos)\nrepos()  # Run with default repos.list\n\n# Or with options\nrepos(\"-f\", \"my-repos.list\")\nrepos(\"--public\")\nrepos(\"--help\")\nRun the repos command:\nlibrary(repos)\nrepos()\nSystem Requirements: The R package requires bash, git, curl, and jq to be installed on your system.\nHow it works: The R package bundles the Bash scripts in inst/scripts/ and provides a wrapper function that locates and executes them using system2().\n\n\nPython Package\nInstall the Python package to use repos from Python or the command line.\nInstall using pip:\n# Install from local clone\ngit clone https://github.com/MiguelRodo/repos.git\ncd repos\npip install .\n\n# Or install in development mode\npip install -e .\n\n# Use the repos command\nrepos  # Run with default repos.list\nrepos -f my-repos.list\nrepos --public\nrepos --help\nRun the repos command:\nrepos\nSystem Requirements: The Python package requires bash, git, curl, and jq to be installed on your system. On Windows, you need Git for Windows (which includes Git Bash) or WSL (Windows Subsystem for Linux).\nHow it works: The Python package bundles the Bash scripts in src/repos/scripts/ and provides both a CLI entry point and a Python API using subprocess.run().\nPython API:\nfrom repos import run_script\n\n# Run the setup script\nrun_script(\"setup-repos.sh\", [\"-f\", \"my-repos.list\"])\n\n# Run other scripts\nrun_script(\"run-pipeline.sh\")\nrun_script(\"add-branch.sh\", [\"feature-x\"])"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Quick Start",
    "text": "Quick Start\n\n1. Create a repos.list file\nCreate a repos.list file in your project directory:\n# Clone full repository\nowner/repo\n\n# Clone specific branch\nowner/repo@branch\n\n# Create worktree from current repo\n@branch-name\n\n# Clone with custom directory name\nowner/repo custom-name\nExample:\n# repos.list\nmyorg/backend\nmyorg/frontend@develop\nmyorg/docs\n\n\n2. Run setup\nrepos\nThis will: 1. Create any missing repositories on GitHub (if you have permissions) 2. Clone all specified repositories to the parent directory 3. Generate a VS Code workspace file\nTo also configure authentication for GitHub Codespaces, use the --codespaces flag or specify devcontainer paths with -d:\n# Enable Codespaces authentication with default path\nrepos --codespaces\n\n# Specify custom devcontainer.json paths\nrepos -d .devcontainer/devcontainer.json\nrepos -d path1/devcontainer.json -d path2/devcontainer.json"
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Usage",
    "text": "Usage\n\nBasic Commands\nThe repos command is a wrapper around setup-repos.sh. All options are passed through:\n# Setup repositories from repos.list\nrepos\n\n# Use a different file\nrepos -f my-repos.list\n\n# Create repositories as public (default is private)\nrepos --public\n\n# Enable Codespaces authentication\nrepos --codespaces\n\n# Specify custom devcontainer.json paths\nrepos -d .devcontainer/devcontainer.json\n\n# Show help\nrepos --help\n\n\nAdvanced Features\nThe package installs additional scripts to /usr/share/repos/scripts/ that you can call directly:\n# Execute pipeline across all repositories\n/usr/share/repos/scripts/run-pipeline.sh\n\n# Create worktrees for parallel development\n/usr/share/repos/scripts/add-branch.sh feature-x\n\n# Sync devcontainer across worktrees\n/usr/share/repos/scripts/update-branches.sh\n\n# Pull latest scripts from template\n/usr/share/repos/scripts/update-scripts.sh\nNote for contributors: When developing/testing from the repository, you can run scripts directly:\nscripts/setup-repos.sh\nscripts/run-pipeline.sh\n\n\nRepository Layout\nAll repositories are cloned to the parent directory of your current location:\nworkspace/\n├── my-project/          # Your main project (contains repos.list)\n├── backend/             # Cloned from myorg/backend\n├── frontend-develop/    # Cloned from myorg/frontend@develop\n└── docs/                # Cloned from myorg/docs\n\n\nrepos.list Format\n# Full repository clone\nowner/repo\n\n# Specific branch clone\nowner/repo@branch\n\n# Worktree from current repository\n@branch-name [optional-target-directory]\n\n# External repository with custom directory\nowner/repo custom-directory\n\n\nRunning Pipelines\nIf your repositories contain run.sh scripts, you can execute them across all repositories:\n/usr/share/repos/scripts/run-pipeline.sh\n\n# With options\n/usr/share/repos/scripts/run-pipeline.sh --skip-setup\n/usr/share/repos/scripts/run-pipeline.sh --include \"backend,frontend\"\n/usr/share/repos/scripts/run-pipeline.sh --dry-run"
  },
  {
    "objectID": "index.html#configuration",
    "href": "index.html#configuration",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Configuration",
    "text": "Configuration\n\nGitHub Authentication\nFor private repositories or creating repos, you need GitHub credentials:\n# Set GitHub token\nexport GH_TOKEN=\"your_github_personal_access_token\"\n\n# Or use gh CLI\ngh auth login\n\n# For Codespaces, add GH_TOKEN as a secret\n\n\nVS Code Workspace\nAfter running repos, open the generated workspace:\ncode entire-project.code-workspace"
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Examples",
    "text": "Examples\n\nExample 1: Clone multiple repositories\n# repos.list\nuser/web-app\nuser/api-server\nuser/database-scripts\n\n# Run\nrepos\n\n\nExample 2: Work on multiple branches\n# repos.list\nmyorg/main-project\n@feature-a\n@feature-b\n@bugfix-123\n\n# Run\nrepos\n\n# Now you have:\n# - myorg/main-project (main branch)\n# - main-project-feature-a (feature-a worktree)\n# - main-project-feature-b (feature-b worktree)\n# - main-project-bugfix-123 (bugfix-123 worktree)\n\n\nExample 3: Mixed repositories and worktrees\n# repos.list\ncompany/backend\ncompany/frontend@develop\n@staging\ncompany/docs\n@preview\n\n# This creates:\n# - backend/ (full clone)\n# - frontend-develop/ (develop branch only)\n# - backend-staging/ (worktree from backend)\n# - docs/ (full clone)\n# - docs-preview/ (worktree from docs)"
  },
  {
    "objectID": "index.html#troubleshooting",
    "href": "index.html#troubleshooting",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\nAuthentication Errors\nIf you see “could not read Username” errors:\nexport GH_TOKEN=\"your_token\"\n# or\ngh auth login\n\n\nPermission Issues\nAfter installation, if /usr/bin/repos is not executable:\nsudo chmod +x /usr/bin/repos\n\n\nMissing Dependencies\nsudo apt-get install bash git curl jq"
  },
  {
    "objectID": "index.html#uninstallation",
    "href": "index.html#uninstallation",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Uninstallation",
    "text": "Uninstallation\nsudo dpkg -r repos"
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "repos - Multi-Repository Management Tool",
    "section": "License",
    "text": "License\nMIT License - see debian/copyright for details"
  },
  {
    "objectID": "index.html#contributing",
    "href": "index.html#contributing",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Contributing",
    "text": "Contributing\nIssues and pull requests welcome at https://github.com/MiguelRodo/repos"
  },
  {
    "objectID": "index.html#author",
    "href": "index.html#author",
    "title": "repos - Multi-Repository Management Tool",
    "section": "Author",
    "text": "Author\nMiguel Rodo miguel.rodo@uct.ac.za"
  }
]